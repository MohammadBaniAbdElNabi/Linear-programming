Traceback (most recent call last):
  File "/usr/local/python/3.12.1/lib/python3.12/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/home/codespace/.local/lib/python3.12/site-packages/nbclient/client.py", line 1319, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/codespace/.local/lib/python3.12/site-packages/jupyter_core/utils/__init__.py", line 165, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/python/3.12.1/lib/python3.12/asyncio/base_events.py", line 684, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/home/codespace/.local/lib/python3.12/site-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/home/codespace/.local/lib/python3.12/site-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/home/codespace/.local/lib/python3.12/site-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
def find_intersection(line1, line2):
    """
    Finds the intersection point of two lines represented in the form (a, b, c) where ax + by = c.

    Args:
        line1: Tuple (a, b, c) representing the first line.
        line2: Tuple (a, b, c) representing the second line.

    Returns:
        A NumPy array representing the intersection point (x, y), or None if the lines are parallel.
    """
    A = np.array([[line1[0], line1[1]], [line2[0], line2[1]]])  # Create a matrix of coefficients
    b = np.array([line1[2], line2[2]])  # Create a vector of constants
    if np.linalg.det(A) == 0:
        return None  # Parallel lines, no intersection
    return np.linalg.solve(A, b)  # Solve the system of equations to find the intersection

def is_feasible(point, constraints):
    """
    Checks if a point (x, y) is feasible (satisfies all constraints).

    Args:
        point: Tuple (x, y) representing the point.
        constraints: A list of tuples, each representing a constraint in the form (a, b, c, sign).

    Returns:
        True if the point is feasible, False otherwise.
    """
    x, y = point
    for a, b, c, sign in constraints:
        if sign == '<' and not (a * x + b * y <= c):  # Check if the point violates a '<=' constraint
            return False
        if sign == '>' and not (a * x + b * y >= c):  # Check if the point violates a '>=' constraint
            return False
    return True  # Point satisfies all constraints

def find_optimal_points(obj_type, a, b, constraints):
    """
    Finds all feasible points and the optimal point.

    Args:
        obj_type: String, either "maximize" or "minimize", indicating the objective.
        a: Coefficient of x in the objective function.
        b: Coefficient of y in the objective function.
        constraints: A list of tuples, each representing a constraint.

    Returns:
        A tuple containing:
            - A NumPy array of feasible points.
            - The optimal point as a NumPy array.
    """
    feasible_points = []
    for (line1, line2) in combinations(constraints, 2):  # Iterate through all pairs of constraints
        intersection = find_intersection(line1, line2)  # Find their intersection
        if intersection is not None and is_feasible(intersection, constraints):  # Check if feasible
            feasible_points.append(intersection)

    feasible_points = np.array(feasible_points)
    if feasible_points.size == 0:
        print("No feasible region found")
        return np.array([]), None

    obj_values = [a * x + b * y for x, y in feasible_points]  # Calculate objective function values
    optimal_index = np.argmax(obj_values) if obj_type == "maximize" else np.argmin(obj_values)  # Find optimal index
    optimal_point = feasible_points[optimal_index]  # Get the optimal point
    return feasible_points, optimal_point

def plot_feasible_region(constraints, x_range, y_range):
    """
    Plots the feasible region defined by the constraints.

    Args:
        constraints: A list of tuples, each representing a constraint.
        x_range: A NumPy array of x-values for the plot.
        y_range: A NumPy array of y-values for the plot.
    """
    x, y = np.meshgrid(x_range, y_range)  # Create a grid of points
    feasible_region = np.ones_like(x, dtype=bool)  # Initialize feasible region as all True

    for a, b, c, sign in constraints:
        if sign == '<':
            feasible_region &= (a * x + b * y <= c)  # Update feasible region based on '<=' constraints
        elif sign == '>':
            feasible_region &= (a * x + b * y >= c)  # Update feasible region based on '>=' constraints

    plt.imshow(feasible_region.astype(int), extent=(x.min(), x.max(), y.min(), y.max()),
               origin="lower", cmap="Greys", alpha=0.3)  # Plot the feasible region

def plot_constraints(constraints, x_range):
    """
    Plots the lines representing the constraints.

    Args:
        constraints: A list of tuples, each representing a constraint.
        x_range: A NumPy array of x-values for the plot.
    """
    for a, b, c, sign in constraints:
        y_vals = np.linspace(0, 10, 2000)  # Generate y-values for the line
        if a != 0:
            x_vals = (c - b * y_vals) / a  # Calculate corresponding x-values
        else:
            x_vals = np.full_like(y_vals, c / b)  # Handle vertical lines (a = 0)
        plt.plot(x_vals, y_vals, label=f'{a}x + {b}y {sign} {c}')  # Plot the line

def graphical_method(obj_type, a, b, constraints):
    """
    Solves a linear programming problem graphically and displays the solution.

    Args:
        obj_type: String, either "maximize" or "minimize", indicating the objective.
        a: Coefficient of x in the objective function.
        b: Coefficient of y in the objective function.
        constraints: A list of tuples, each representing a constraint.
    """
    x_range = np.linspace(0, 16, 300)  # Define the range of x-values for the plot
    y_range = np.linspace(0, 10, 300)  # Define the range of y-values for the plot
    plt.figure(figsize=(8, 8))  # Create a figure for the plot
    plot_feasible_region(constraints, x_range, y_range)  # Plot the feasible region
    plot_constraints(constraints, x_range)  # Plot the constraint lines

    feasible_points, optimal_point = find_optimal_points(obj_type, a, b, constraints)  # Find feasible and optimal points

    if feasible_points.size > 0:
        feasible_x, feasible_y = zip(*feasible_points)  # Extract x and y coordinates of feasible points
        plt.scatter(feasible_x, feasible_y, color='blue', label='Feasible Points')  # Plot feasible points

    if optimal_point is not None:
        plt.scatter(*optimal_point, color='red', s=100, label='Optimal Point', edgecolors='black')  # Plot optimal point

    plt.xlim(0, 16)  # Set x-axis limits
    plt.ylim(0, 10)  # Set y-axis limits
    plt.xlabel(r'$x$')  # Label x-axis
    plt.ylabel(r'$y$')  # Label y-axis
    plt.legend(loc='upper right')  # Place legend in upper right corner
    plt.title(f"{obj_type.capitalize()} Objective Function")  # Set plot title
    plt.grid(True)  # Show grid
    plt.show()  # Display the plot



def solve_example():
    """
    Defines and solves an example linear programming problem.
    """
    # Example problem definition: objective function, coefficients, and constraints
    example = [
        ("maximize", 3, 1, [(1, 1, 10, '<'), (0, 1, 5, '<'), (-1, 1, -2, '>'), (1, 0, 0, '>'), (0, 1, 0, '>')])
    ]

    # Solve the example problem using the graphical method
    for obj_type, a, b, constraints in example:
        graphical_method(obj_type, a, b, constraints)


solve_example() # Call the solve_example function to run the code
------------------


[31m---------------------------------------------------------------------------[39m
[31mNameError[39m                                 Traceback (most recent call last)
[36mCell[39m[36m [39m[32mIn[1][39m[32m, line 155[39m
[32m    151[39m     [38;5;28;01mfor[39;00m obj_type, a, b, constraints [38;5;129;01min[39;00m example:
[32m    152[39m         graphical_method(obj_type, a, b, constraints)
[32m--> [39m[32m155[39m [43msolve_example[49m[43m([49m[43m)[49m [38;5;66;03m# Call the solve_example function to run the code[39;00m

[36mCell[39m[36m [39m[32mIn[1][39m[32m, line 152[39m, in [36msolve_example[39m[34m()[39m
[32m    150[39m [38;5;66;03m# Solve the example problem using the graphical method[39;00m
[32m    151[39m [38;5;28;01mfor[39;00m obj_type, a, b, constraints [38;5;129;01min[39;00m example:
[32m--> [39m[32m152[39m     [43mgraphical_method[49m[43m([49m[43mobj_type[49m[43m,[49m[43m [49m[43ma[49m[43m,[49m[43m [49m[43mb[49m[43m,[49m[43m [49m[43mconstraints[49m[43m)[49m

[36mCell[39m[36m [39m[32mIn[1][39m[32m, line 115[39m, in [36mgraphical_method[39m[34m(obj_type, a, b, constraints)[39m
[32m    105[39m [38;5;28;01mdef[39;00m[38;5;250m [39m[34mgraphical_method[39m(obj_type, a, b, constraints):
[32m    106[39m [38;5;250m    [39m[33;03m"""[39;00m
[32m    107[39m [33;03m    Solves a linear programming problem graphically and displays the solution.[39;00m
[32m    108[39m 
[32m   (...)[39m[32m    113[39m [33;03m        constraints: A list of tuples, each representing a constraint.[39;00m
[32m    114[39m [33;03m    """[39;00m
[32m--> [39m[32m115[39m     x_range = [43mnp[49m.linspace([32m0[39m, [32m16[39m, [32m300[39m)  [38;5;66;03m# Define the range of x-values for the plot[39;00m
[32m    116[39m     y_range = np.linspace([32m0[39m, [32m10[39m, [32m300[39m)  [38;5;66;03m# Define the range of y-values for the plot[39;00m
[32m    117[39m     plt.figure(figsize=([32m8[39m, [32m8[39m))  [38;5;66;03m# Create a figure for the plot[39;00m

[31mNameError[39m: name 'np' is not defined

