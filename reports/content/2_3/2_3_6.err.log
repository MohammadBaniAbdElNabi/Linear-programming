Traceback (most recent call last):
  File "/usr/local/python/3.12.1/lib/python3.12/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/home/codespace/.local/lib/python3.12/site-packages/nbclient/client.py", line 1319, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/codespace/.local/lib/python3.12/site-packages/jupyter_core/utils/__init__.py", line 165, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/python/3.12.1/lib/python3.12/asyncio/base_events.py", line 684, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/home/codespace/.local/lib/python3.12/site-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/home/codespace/.local/lib/python3.12/site-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/home/codespace/.local/lib/python3.12/site-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
def find_intersection(line1, line2):
    A = np.array([[line1[0], line1[1]], [line2[0], line2[1]]])
    b = np.array([line1[2], line2[2]])
    if np.linalg.det(A) == 0:
        return None  # Parallel lines, no intersection
    return np.linalg.solve(A, b)

def is_feasible(point, constraints):
    x, y = point
    for a, b, c, sign in constraints:
        if sign == '<' and not (a * x + b * y <= c):
            return False
        if sign == '>' and not (a * x + b * y >= c):
            return False
    return True

def find_optimal_points(obj_type, a, b, constraints):
    feasible_points = []
    for (line1, line2) in combinations(constraints, 2):
        intersection = find_intersection(line1, line2)
        if intersection is not None and is_feasible(intersection, constraints):
            feasible_points.append(intersection)

    feasible_points = np.array(feasible_points)
    if feasible_points.size == 0:
        return np.array([]), None

    obj_values = [a * x + b * y for x, y in feasible_points]
    optimal_index = np.argmax(obj_values) if obj_type == "maximize" else np.argmin(obj_values)
    optimal_point = feasible_points[optimal_index]
    return feasible_points, optimal_point

def plot_feasible_region_and_objective(constraints, a, b, obj_type, x_range, y_range):
    x, y = np.meshgrid(x_range, y_range)
    feasible_region = np.ones_like(x, dtype=bool)

    for a_c, b_c, c_c, sign in constraints:
        if sign == '<':
            feasible_region &= (a_c * x + b_c * y <= c_c)
        elif sign == '>':
            feasible_region &= (a_c * x + b_c * y >= c_c)

    plt.imshow(feasible_region.astype(int), extent=(x.min(), x.max(), y.min(), y.max()), origin="lower", cmap="Greys", alpha=0.3)

    for a_c, b_c, c_c, sign in constraints:
        y_vals = np.linspace(y_range.min(), y_range.max(), 200)
        if a_c != 0:
            x_vals = (c_c - b_c * y_vals) / a_c
        else:
            x_vals = np.full_like(y_vals, c_c / b_c)
        plt.plot(x_vals, y_vals, label=f'{a_c}x + {b_c}y {sign} {c_c}')

    feasible_points, optimal_point = find_optimal_points(obj_type, a, b, constraints)
    if feasible_points.size > 0:
        feasible_x, feasible_y = zip(*feasible_points)
        plt.scatter(feasible_x, feasible_y, color='blue', label='Feasible Points')

    if optimal_point is not None:
        plt.scatter(*optimal_point, color='red', s=100, label='Optimal Point', edgecolors='black')

    obj_x = np.linspace(x_range.min(), x_range.max(), 200)
    obj_y = (-a * obj_x) / b if b != 0 else np.full_like(obj_x, 0)
    plt.plot(obj_x, obj_y, '--r', label='Objective Function')

    plt.xlim(x_range.min(), x_range.max())
    plt.ylim(y_range.min(), y_range.max())
    plt.xlabel(r'$x$')
    plt.ylabel(r'$y$')
    plt.legend(loc='upper right')
    plt.title(f"{obj_type.capitalize()} Objective Function")
    plt.grid(True)
    plt.show()

def update_plot(obj_type, a, b, *constraint_values):
    num_constraints = len(constraint_values) // 4
    constraints = [(constraint_values[i * 4], constraint_values[i * 4 + 1], constraint_values[i * 4 + 2], constraint_values[i * 4 + 3]) for i in range(num_constraints)]

    x_range = np.linspace(0, 16, 300)
    y_range = np.linspace(0, 10, 300)
    plt.figure(figsize=(8, 8))
    plot_feasible_region_and_objective(constraints, a, b, obj_type, x_range, y_range)

def interactive_solver():
    obj_type = widgets.Dropdown(
        options=['maximize', 'minimize'],
        description='Objective:',
    )

    a_slider = widgets.FloatSlider(value=1, min=-20, max=20, step=1, description='a (x):')
    b_slider = widgets.FloatSlider(value=1, min=-20, max=20, step=1, description='b (y):')

    num_constraints = widgets.Dropdown(options=[1, 2, 3, 4, 5, 6], description='Constraints:')

    constraint_sliders = []
    def update_constraints(*args):
        nonlocal constraint_sliders
        for slider in constraint_sliders:
            slider.close()
        constraint_sliders.clear()

        for i in range(num_constraints.value):
            a_s = widgets.FloatSlider(value=1, min=-20, max=20, step=1, description=f'a{i+1}:')
            b_s = widgets.FloatSlider(value=1, min=-20, max=20, step=1, description=f'b{i+1}:')
            c_s = widgets.FloatSlider(value=5, min=-20, max=20, step=1, description=f'c{i+1}:')
            sign_s = widgets.Dropdown(options=['<', '>'], description=f'sign{i+1}:')
            constraint_sliders.extend([a_s, b_s, c_s, sign_s])
        display_controls()

    num_constraints.observe(update_constraints, names='value')

    def display_controls():
        ui = widgets.VBox([obj_type, a_slider, b_slider, num_constraints] + constraint_sliders)
        output = widgets.Output()

        def update(_):
            with output:
                output.clear_output(wait=True)
                update_plot(obj_type.value, a_slider.value, b_slider.value, *[s.value for s in constraint_sliders])

        for slider in [a_slider, b_slider, num_constraints] + constraint_sliders + [obj_type]:
            slider.observe(update, names='value')

        display(ui, output)
        update(None)

    update_constraints()

interactive_solver()
------------------


[31m---------------------------------------------------------------------------[39m
[31mNameError[39m                                 Traceback (most recent call last)
[36mCell[39m[36m [39m[32mIn[1][39m[32m, line 128[39m
[32m    124[39m         update([38;5;28;01mNone[39;00m)
[32m    126[39m     update_constraints()
[32m--> [39m[32m128[39m [43minteractive_solver[49m[43m([49m[43m)[49m

[36mCell[39m[36m [39m[32mIn[1][39m[32m, line 84[39m, in [36minteractive_solver[39m[34m()[39m
[32m     83[39m [38;5;28;01mdef[39;00m[38;5;250m [39m[34minteractive_solver[39m():
[32m---> [39m[32m84[39m     obj_type = [43mwidgets[49m.Dropdown(
[32m     85[39m         options=[[33m'[39m[33mmaximize[39m[33m'[39m, [33m'[39m[33mminimize[39m[33m'[39m],
[32m     86[39m         description=[33m'[39m[33mObjective:[39m[33m'[39m,
[32m     87[39m     )
[32m     89[39m     a_slider = widgets.FloatSlider(value=[32m1[39m, [38;5;28mmin[39m=-[32m20[39m, [38;5;28mmax[39m=[32m20[39m, step=[32m1[39m, description=[33m'[39m[33ma (x):[39m[33m'[39m)
[32m     90[39m     b_slider = widgets.FloatSlider(value=[32m1[39m, [38;5;28mmin[39m=-[32m20[39m, [38;5;28mmax[39m=[32m20[39m, step=[32m1[39m, description=[33m'[39m[33mb (y):[39m[33m'[39m)

[31mNameError[39m: name 'widgets' is not defined

